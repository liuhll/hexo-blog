---
title: 设计模式之适配器模式
date: 2018-10-21 22:52:18
categories: "设计模式"
tags:
  - 适配器模式
  - 结构型
  - 设计模式
---

## 介绍
适配器模式实际上就是一个转换的过程,把不能一起工作的两样东西通过转换，让他们能够在一起工作。在现实中的例子比如:手机的充电器，充电器的接头，有的是把两相电转换为三相电的，当然也有把三相电转换成两相电的。使用笔记本电脑，笔记本电脑的工作电压和我们家里照明电压是不一致的，当然也就需要充电器把照明电压转换成笔记本的工作电压，只有这样笔记本电脑才可以正常工作。

## 动机
在软件系统中，由于应用环境的变化，常常需要将**一些现存的对象**放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。如何应对这种“迁移的变化”？如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？

## 意图
将一个类的接口转换成客户希望的另一个接口。`Adapter模式`使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。  

## 结构图
适配器有两种类型:一种是对象适配器，一种是类适配器,相对而言,对象适配器更为常用。

### 对象适配器
对象适配器使用的是对象组合的方案，它的`Adapter`和`Adaptee`的关系是组合关系。
`OO`中优先使用组合模式，组合模式不适用再考虑继承。因为组合模式更加松耦合，而继承是紧耦合的，父类的任何改动都要导致子类的改动。
![对象适配器](object-adapter-pattern.png)

### 类适配器
类适配器使用的是继承的方案，`Adapter`和`Adaptee`的关系是继承关系。
![类适配器](class-adapter-pattern.png)
## 角色组成
1. **目标角色（Target）**：定义`Client`使用的与特定领域相关的接口。
2. **客户角色（Client）**：与符合`Target`接口的对象协同。
3. **被适配角色（Adaptee)**：定义一个已经存在并已经使用的接口，这个接口需要适配。
4. **适配器角色（Adapte)**：适配器模式的核心。它将对被适配`Adaptee`角色已有的接口转换为目标角色`Target`匹配的接口。对`Adaptee`的接口与`Target`接口进行适配.

## 实现

### 对象适配器的实现

```csharp
namespace 对象的适配器模式
{
    ////////////////////////////////////////////////////////
    // 客户端调用
    ////////////////////////////////////////////////////////
    ///<summary>
    ///家里只有两个孔的插座，也懒得买插线板了，还要花钱，但是我的手机是一个有3个小柱子的插头，明显直接搞不定，那就适配吧
    ///</summary>
    class Client
    {
        static void Main(string[] args)
        {
            //好了，现在就可以给手机充电了
            TwoHoleTarget homeTwoHole = new ThreeToTwoAdapter();
            homeTwoHole.Request();
            Console.ReadLine();
        }
    }

    ////////////////////////////////////////////////////////
    // 目标角色（Target）
    ////////////////////////////////////////////////////////
    /// <summary>
    /// 我家只有2个孔的插座，也就是适配器模式中的目标(Target)角色，这里可以写成抽象类或者接口
    /// </summary>
    public class TwoHoleTarget
    {
        // 客户端需要的方法
        public virtual void Request()
        {
            Console.WriteLine("两孔的充电器可以使用");
        }
    }

    ////////////////////////////////////////////////////////
    // 被适配角色（Adaptee)
    ////////////////////////////////////////////////////////
    /// <summary>
    /// 手机充电器是有3个柱子的插头，源角色——需要适配的类（Adaptee）
    /// </summary>
    public class ThreeHoleAdaptee
    {
        public void SpecificRequest()
        {
            Console.WriteLine("我是3个孔的插头也可以使用了");
        }
    }

    ////////////////////////////////////////////////////////
    // 适配器类
    ////////////////////////////////////////////////////////
    /// <summary>
    /// 适配器类，TwoHole这个对象写成接口或者抽象类更好，面向接口编程嘛
    /// </summary>
    public class ThreeToTwoAdapter : TwoHoleTarget
    {
        // 引用两个孔插头的实例,从而将客户端与TwoHole联系起来
        private ThreeHoleAdaptee threeHoleAdaptee = new ThreeHoleAdaptee();
        //这里可以继续增加适配的对象。。

        /// <summary>
        /// 实现2个孔插头接口方法
        /// </summary>
        public override void Request()
        {
            //可以做具体的转换工作
            threeHoleAdaptee.SpecificRequest();
            //可以做具体的转换工作
        }
    }
}
```

### 类适配器的实现

```csharp
namespace 设计模式之适配器模式
{
    ////////////////////////////////////////////////////////
    // 客户端调用
    ////////////////////////////////////////////////////////
    /// <summary>
    /// 这里手机充电器为例，我们的家的插座是两相电的，但是手机的插座接头是三相电的
    /// </summary>
    class Client
    {
        static void Main(string[] args)
        {
            //好了，现在可以充电了
            ITwoHoleTarget change = new ThreeToTwoAdapter();
            change.Request();
            Console.ReadLine();
        }
    }
 
    ////////////////////////////////////////////////////////
    // 目标角色（Target）
    //////////////////////////////////////////////////////// 
    /// <summary>
    /// 我家只有2个孔的插座，也就是适配器模式中的目标角色（Target），这里只能是接口，也是类适配器的限制
    /// </summary>
    public interface ITwoHoleTarget
    {
        void Request();
    }
 
    ////////////////////////////////////////////////////////
    // 被适配角色（Adaptee)
    //////////////////////////////////////////////////////// 
    /// <summary>
    /// 3个孔的插头，源角色——需要适配的类（Adaptee）
    /// </summary>
    public abstract class ThreeHoleAdaptee
    {
        public void SpecificRequest()
        {
            Console.WriteLine("我是三个孔的插头");
        }
    }
 
    ////////////////////////////////////////////////////////
    // 适配器角色（Adapte) 
    //////////////////////////////////////////////////////// 
    /// <summary>
    /// 适配器类，接口要放在类的后面，在此无法适配更多的对象，这是类适配器的不足
    /// </summary>
    public class ThreeToTwoAdapter:ThreeHoleAdaptee,ITwoHoleTarget
    {
        /// <summary>
        /// 实现2个孔插头接口方法
        /// </summary>
        public void Request()
        {
            // 调用3个孔插头方法
            this.SpecificRequest();
        }
    }
}
```


## 实现要点
1. `Adapter模式`主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，*在遗留代码复用、类库迁移等方面非常有用。*

2. GoF23定义了两种Adapter模式的实现结构：`对象适配器`和`类适配器`
  - `类适配器`采用**多继承**的实现方式，在C#语言中，如果被适配角色是类，Target的实现只能是接口，因为C#语言只支持接口的多继承的特性。在C#语言中类适配器也很难支持适配多个对象的情况，同时也会带来了不良的高耦合和违反类的职责单一的原则，所以一般不推荐使用。
  - `对象适配器`采用**对象组合**的方式，更符合松耦合精神，对适配的对象也没限制，可以一个，也可以多个，但是，使得重定义`Adaptee`的行为较困难，这就需要生成`Adaptee`的子类并且使得`Adapter`引用这个子类而不是引用`Adaptee`本身。
3. `Adapter模式`可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将`Adapter`模式中的“现存对象”作为新的接口方法参数，来达到适配的目的。
4. `Adapter模式`本身要求我们尽可能地使用“面向接口的编程”风格，这样才能在后期很方便地适配。

## 优缺点

### 对象适配器的优缺点
#### 优点
1. 可以在不修改原有代码的基础上来复用现有类，很好地符合 “开闭原则”（这点是两种实现方式都具有的）
2. 采用 “对象组合”的方式，更符合松耦合。

#### 缺点
1. 使得重定义`Adaptee`的行为较困难，这就需要生成`Adaptee`的子类并且使得`Adapter`引用这个子类而不是引用`Adaptee`本身。

### 类适配器的优缺点
#### 优点
1. 可以在不修改原有代码的基础上来复用现有类，很好地符合 “开闭原则”
2. 可以重新定义`Adaptee`(被适配的类)的部分行为，因为在类适配器模式中，`Adapter`是`Adaptee`的子类
3. 仅仅引入一个对象，并不需要额外的字段来引用`Adaptee`实例（这个即是优点也是缺点）。
#### 缺点
1. 用一个具体的`Adapter`类对`Adaptee`和`Target`进行匹配，当如果想要匹配一个类以及所有它的子类时，类的适配器模式就不能胜任了。因为类的适配器模式中没有引入`Adaptee`的实例，光调用`this.SpecificRequest`方法并不能去调用它对应子类的`SpecificRequest`方法。
2. 采用了 “多继承”的实现方式，带来了不良的高耦合。

## 适配器的使用场景
1. 系统需要复用现有类，而该类的接口不符合系统的需求
2. 想要建立一个可重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。
3. 对于对象适配器模式，在设计里需要改变多个已有子类的接口，如果使用类的适配器模式，就要针对每一个子类做一个适配器，而这不太实际。
