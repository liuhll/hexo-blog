---
title: 设计模式之外观模式
date: 2018-11-4 21:38:00
categories: "设计模式"
tags:
  - 外观模式
  - 结构型
---

# 简介
外观模式（Facade Pattern）,又称作门面模式，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种架构设计模式。
这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。
![外观模式](facede-pattern-intro.png)

# 动机
在软件系统开发的过程中，当组件的客户（即外部接口，或客户程序）和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？

# 意图
为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

# 结构图
![外观模式](facede-pattern.jpg)

# 角色
1. **外观角色（Facade）**：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。
2. **子系统角色（SubSystem）**：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。

# 实现
```csharp
namespace 外观模式的实现
{
    /// <summary>
    /// 不使用外观模式的情况
    /// 此时客户端与三个子系统都发送了耦合，使得客户端程序依赖与子系统
    /// 为了解决这样的问题，我们可以使用外观模式来为所有子系统设计一个统一的接口
    /// 客户端只需要调用外观类中的方法就可以了，简化了客户端的操作
    /// 从而让客户和子系统之间避免了紧耦合
    /// </summary>
    class Client
    {
        static void Main(string[] args)
        {
            var facade=new SystemFacade();
            facade.Buy();
            Console.Read();
        }
    }
 
    // 身份认证子系统A
    public class AuthoriationSystemA
    {
        public void MethodA()
        {
            Console.WriteLine("执行身份认证");
        }
    }
 
    // 系统安全子系统B
    public class SecuritySystemB
    {
        public void MethodB()
        {
            Console.WriteLine("执行系统安全检查");
        }
    }
 
    // 网银安全子系统C
    public class NetBankSystemC
    {
        public void MethodC()
        {
            Console.WriteLine("执行网银安全检测");
        }
    }

   //更高层的Facade
   public class SystemFacade
   {
      private AuthoriationSystemA auth;
      private SecuritySystemB security;
      private NetBankSystemC netbank;

      public SystemFacade()
      {
         auth=new AuthoriationSystemA();
         security=new SecuritySystemB();
         netbank=new NetBankSystemC();
      }

      public void Buy()
      {
          auth.MethodA();//身份认证子系统
          security.MethodB();//系统安全子系统
          netbank.MethodC();//网银安全子系统

          Console.WriteLine("我已经成功购买了！");
      }
   }
}
```

## 实现要点
1. 一个系统可以有几个门面类
  - 在门面模式中，通常只需要一个门面类，并且此门面类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只有一个门面类，而仅仅是说对每一个子系统只有一个门面类。或者说，如果一个系统有好几个子系统的话，每一个子系统都有一个门面类，整个系统可以有数个门面类。

2. 为子系统增加新行为
  - 初学者往往以为通过继承一个门面类便可在子系统中加入新的行为，*这是错误的。* 门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。比如医院中的接待员并不是医护人员，接待员并不能为病人提供医疗服务。

3. Facade有助于建立层次结构的系统，实现了子系统与客户之间的松耦合关系，子系统内部的功能组件往往是紧耦合的。松耦合关系使得子系统的组件变化不会影响到它的客户。Facade消除了复杂的循环依赖关系。这一点在客户程序与子系统分别实现的时候格外重要。

4. 从客户程序的角度来看，Facade模式不仅简化了整个组件系统的接口，同时对于组件内部与外部客户程序来说，从某种程度上也达到了一种“解耦”的效果——内部子系统的任何变化不会影响到Facade接口的变化。


# 优缺点

## 优点
1. 外观模式对客户屏蔽了子系统组件，从而简化了接口，减少了客户处理的对象数目并使子系统的使用更加简单。
2. 外观模式实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件是紧耦合的。松耦合使得子系统的组件变化不会影响到它的客户。

## 缺点
1. 如果增加新的子系统可能需要修改外观类或客户端的源代码，这样就违背了**开——闭原则**（不过这点也是不可避免）。

# 使用场景
1. 对外一个复杂的子系统提供一个简单的接口
2. 提供子系统的独立性
3. 在层次化结构中，可以使用外观模式定义系统中每一层的入口。其中三层架构就是这样的一个例子。 

# 模式比较

注意区分Facade模式、Adapter模式、Bridge模式与Decorator模式：

- Facade模式注重简化接口
- Adapter模式注重转换接口
- Bridge模式注重分离接口（抽象）与其实现
- Decorator模式注重稳定接口的前提下为对象扩展功能